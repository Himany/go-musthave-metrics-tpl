package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

type packageData struct {
	name    string
	dir     string
	fset    *token.FileSet
	structs []structInfo
}

type structInfo struct {
	name string
	node *ast.StructType
	file *ast.File
	fset *token.FileSet
}

func main() {
	root, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}

	pkgs, err := collectPackages(root)
	if err != nil {
		log.Fatal(err)
	}

	var errs []string
	for _, pkg := range pkgs {
		if len(pkg.structs) == 0 {
			if err := os.Remove(filepath.Join(pkg.dir, "reset.gen.go")); err != nil && !errors.Is(err, os.ErrNotExist) {
				errs = append(errs, fmt.Sprintf("%s: %v", pkg.dir, err))
			}
			continue
		}
		if err := generatePackageFile(pkg); err != nil {
			errs = append(errs, fmt.Sprintf("%s: %v", pkg.dir, err))
		}
	}

	if len(errs) > 0 {
		log.Fatalf("reset: %s", strings.Join(errs, "; "))
	}
}

func collectPackages(root string) ([]packageData, error) {
	var result []packageData
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if !d.IsDir() {
			return nil
		}

		name := d.Name()
		if name == "vendor" || name == ".git" {
			return filepath.SkipDir
		}
		if strings.HasPrefix(name, ".") && path != root {
			return filepath.SkipDir
		}

		rel, relErr := filepath.Rel(root, path)
		if relErr == nil {
			rel = filepath.ToSlash(rel)
			if rel == "cmd/reset" || strings.HasPrefix(rel, "cmd/reset/") {
				return filepath.SkipDir
			}
		}

		hasGo := false
		dirEntries, readErr := os.ReadDir(path)
		if readErr != nil {
			return readErr
		}
		for _, entry := range dirEntries {
			if entry.IsDir() {
				continue
			}
			if strings.HasSuffix(entry.Name(), ".go") && !strings.HasSuffix(entry.Name(), "_test.go") {
				hasGo = true
				break
			}
		}
		if !hasGo {
			return nil
		}

		fset := token.NewFileSet()
		pkgs, parseErr := parser.ParseDir(fset, path, func(info fs.FileInfo) bool {
			name := info.Name()
			return strings.HasSuffix(name, ".go") && !strings.HasSuffix(name, "_test.go")
		}, parser.ParseComments)
		if parseErr != nil {
			return parseErr
		}

		for pkgName, pkgAST := range pkgs {
			pkgData := packageData{name: pkgName, dir: path, fset: fset}
			for _, file := range pkgAST.Files {
				collectStructs(&pkgData, file)
			}
			result = append(result, pkgData)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}

	sort.Slice(result, func(i, j int) bool {
		if result[i].dir == result[j].dir {
			return result[i].name < result[j].name
		}
		return result[i].dir < result[j].dir
	})

	return result, nil
}

func collectStructs(pkg *packageData, file *ast.File) {
	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}

		for _, spec := range gen.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if !hasResetDirective(gen.Doc) && !hasResetDirective(typeSpec.Doc) {
				continue
			}
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}
			pkg.structs = append(pkg.structs, structInfo{name: typeSpec.Name.Name, node: structType, file: file, fset: pkg.fset})
		}
	}
}

func hasResetDirective(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}
	for _, comment := range doc.List {
		text := strings.TrimSpace(comment.Text)
		if strings.HasPrefix(text, "//") {
			text = strings.TrimSpace(strings.TrimPrefix(text, "//"))
		} else if strings.HasPrefix(text, "/*") {
			text = strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(text, "/*"), "*/"))
		}
		if strings.HasPrefix(text, "generate:reset") {
			return true
		}
	}
	return false
}

func generatePackageFile(pkg packageData) error {
	var buf bytes.Buffer
	fmt.Fprintln(&buf, "// Code generated by cmd/reset; DO NOT EDIT.")
	fmt.Fprintf(&buf, "package %s\n\n", pkg.name)

	gen := generator{pkg: pkg}
	for i, st := range pkg.structs {
		if i > 0 {
			fmt.Fprintln(&buf)
		}
		gen.writeStruct(&buf, st)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format output: %w", err)
	}

	return os.WriteFile(filepath.Join(pkg.dir, "reset.gen.go"), formatted, 0o644)
}

type generator struct {
	pkg packageData
}

func (g generator) writeStruct(buf *bytes.Buffer, st structInfo) {
	receiver := receiverName(st.name)
	fmt.Fprintf(buf, "func (%s *%s) Reset() {\n", receiver, st.name)
	fmt.Fprintf(buf, "\tif %s == nil {\n\t\treturn\n\t}\n", receiver)

	bodyWritten := false
	for _, field := range st.node.Fields.List {
		stmts := g.fieldStatements(receiver, field)
		if len(stmts) == 0 {
			continue
		}
		if !bodyWritten {
			fmt.Fprintln(buf)
			bodyWritten = true
		}
		for _, stmt := range stmts {
			fmt.Fprintf(buf, "\t%s\n", stmt)
		}
	}

	fmt.Fprintln(buf, "}")
}

func (g generator) fieldStatements(receiver string, field *ast.Field) []string {
	var names []string
	if len(field.Names) == 0 {
		name := embeddedFieldName(field.Type)
		if name != "" {
			names = append(names, name)
		}
	} else {
		for _, ident := range field.Names {
			names = append(names, ident.Name)
		}
	}
	if len(names) == 0 {
		return nil
	}

	var result []string
	for _, name := range names {
		expr := fmt.Sprintf("%s.%s", receiver, name)
		result = append(result, g.resetStatements(expr, field.Type)...)
	}
	return result
}

func (g generator) resetStatements(expr string, typ ast.Expr) []string {
	switch t := typ.(type) {
	case *ast.Ident:
		if zero, ok := primitiveZeroValues[t.Name]; ok {
			return []string{fmt.Sprintf("%s = %s", expr, zero)}
		}
		return g.structAssignment(expr, typ)
	case *ast.StructType:
		return g.structAssignment(expr, typ)
	case *ast.ArrayType:
		if t.Len == nil {
			return []string{fmt.Sprintf("%s = %s[:0]", expr, expr)}
		}
		return []string{fmt.Sprintf("%s = %s", expr, g.typeZero(typ))}
	case *ast.MapType:
		return []string{fmt.Sprintf("clear(%s)", expr)}
	case *ast.StarExpr:
		return g.pointerStatements(expr, t.X)
	case *ast.InterfaceType, *ast.FuncType, *ast.ChanType:
		return []string{fmt.Sprintf("%s = nil", expr)}
	case *ast.SelectorExpr, *ast.IndexExpr, *ast.IndexListExpr:
		return g.structAssignment(expr, typ)
	default:
		return []string{fmt.Sprintf("%s = %s", expr, g.typeZero(typ))}
	}
}

func (g generator) pointerStatements(expr string, elem ast.Expr) []string {
	inner := g.pointerInner(expr, elem)
	var lines []string
	lines = append(lines, fmt.Sprintf("if %s != nil {", expr))
	lines = append(lines, fmt.Sprintf("\tif resetter, ok := interface{}(%s).(interface{ Reset() }); ok {", expr))
	lines = append(lines, "\t\tresetter.Reset()")
	if len(inner) > 0 {
		lines = append(lines, "\t} else {")
		for _, stmt := range inner {
			lines = append(lines, "\t\t"+stmt)
		}
		lines = append(lines, "\t}")
	} else {
		lines = append(lines, "\t}")
	}
	lines = append(lines, "}")
	return lines
}

func (g generator) pointerInner(expr string, elem ast.Expr) []string {
	deref := fmt.Sprintf("*%s", expr)
	switch t := elem.(type) {
	case *ast.Ident:
		if zero, ok := primitiveZeroValues[t.Name]; ok {
			return []string{fmt.Sprintf("%s = %s", deref, zero)}
		}
		zero := g.typeZero(elem)
		if zero == "" {
			return nil
		}
		return []string{fmt.Sprintf("%s = %s", deref, zero)}
	case *ast.ArrayType:
		if t.Len == nil {
			return []string{fmt.Sprintf("%s = (%s)[:0]", deref, deref)}
		}
		zero := g.typeZero(elem)
		if zero == "" {
			return nil
		}
		return []string{fmt.Sprintf("%s = %s", deref, zero)}
	case *ast.MapType:
		return []string{fmt.Sprintf("clear(%s)", deref)}
	case *ast.StructType, *ast.SelectorExpr, *ast.IndexExpr, *ast.IndexListExpr:
		zero := g.typeZero(elem)
		if zero == "" {
			return nil
		}
		return []string{fmt.Sprintf("%s = %s", deref, zero)}
	case *ast.InterfaceType, *ast.FuncType, *ast.ChanType:
		return []string{fmt.Sprintf("%s = nil", deref)}
	case *ast.StarExpr:
		return []string{fmt.Sprintf("%s = nil", deref)}
	default:
		zero := g.typeZero(elem)
		if zero == "" {
			return nil
		}
		return []string{fmt.Sprintf("%s = %s", deref, zero)}
	}
}

func (g generator) structAssignment(expr string, typ ast.Expr) []string {
	zero := g.typeZero(typ)
	if zero == "" {
		return nil
	}
	return []string{
		fmt.Sprintf("if resetter, ok := interface{}(&%s).(interface{ Reset() }); ok {", expr),
		"\tresetter.Reset()",
		"} else {",
		fmt.Sprintf("\t%s = %s", expr, zero),
		"}",
	}
}

func (g generator) typeZero(expr ast.Expr) string {
	var buf bytes.Buffer
	if err := format.Node(&buf, g.pkg.fset, expr); err != nil {
		return ""
	}
	text := buf.String()
	if text == "" {
		return ""
	}
	switch expr.(type) {
	case *ast.InterfaceType, *ast.FuncType, *ast.ChanType:
		return "nil"
	case *ast.StarExpr:
		return "nil"
	case *ast.MapType:
		return "nil"
	case *ast.ArrayType:
		return fmt.Sprintf("%s{}", text)
	case *ast.StructType:
		return fmt.Sprintf("%s{}", text)
	}
	return fmt.Sprintf("*new(%s)", text)
}

func embeddedFieldName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		return t.Sel.Name
	case *ast.StarExpr:
		return embeddedFieldName(t.X)
	default:
		return ""
	}
}

func receiverName(name string) string {
	if name == "" {
		return "s"
	}
	runes := []rune(name)
	first := unicode.ToLower(runes[0])
	if first == '_' {
		return "s"
	}
	return string(first)
}

var primitiveZeroValues = map[string]string{
	"bool":       "false",
	"string":     "\"\"",
	"int":        "0",
	"int8":       "0",
	"int16":      "0",
	"int32":      "0",
	"int64":      "0",
	"uint":       "0",
	"uint8":      "0",
	"uint16":     "0",
	"uint32":     "0",
	"uint64":     "0",
	"uintptr":    "0",
	"byte":       "0",
	"rune":       "0",
	"float32":    "0",
	"float64":    "0",
	"complex64":  "0",
	"complex128": "0",
}
